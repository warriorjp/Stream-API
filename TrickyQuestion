When calling testMethod(null), both testMethod(Object) and testMethod(String) are potential candidates.
Since String is a subclass of Object, Java will prefer the most specific method. So, the String version should be selected.

public class TestClass {
    public void testMethod(Object obj) {
        System.out.println("Object method called");
    }

    public void testMethod(String str) {
        System.out.println("String method called");
    }

    public static void main(String[] args) {
        TestClass obj = new TestClass();
        obj.testMethod(null);
    }
}


However, if both methods had similarly specific parameters (like Integer and String), Java would throw a compilation error due to ambiguity.
//ambiguty issue
public void testMethod(Integer inte) {
        System.out.println("Integer method called");
    }

    public void testMethod(String str) {
        System.out.println("String method called");
    }
____________________________________________________________________________________________________________________________________________
Feature	start()	run() : 
->Start Create a new thread and execute run() in that new thread.	
->Runs run() in the current thread (does not create a new thread).
->Use start() when you want true parallel execution using multiple threads.
->Calling run() directly executes it like a normal method and does not create a new thread.

->The run() method contains the logic to execute when a thread starts.
->The Thread class internally calls run() when start() is invoked.

class MyThread extends Thread {
    public void run() {
        System.out.println(Thread.currentThread().getName() + " is running");
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();

        t1.start(); // Creates a new thread
        t2.start(); // Creates another new thread

        t1.run(); // Runs like a normal method in the main thread
        t2.run();
    }
}

OUTPUT :
Thread-0 is running
Thread-1 is running
main is running
main is running


____________________________________________________________________________________________________________________________________________
In Java, if two interfaces have the same method signature but different return types, and a class tries to implement both interfaces,
it will cause a compilation error due to ambiguity in the return type.
- Java doesn't allow method overloading based only on return type.

interface A {
    int show();
}

interface B {
    String show();
}

class C implements A, B {  // Compilation Error
    @Override
    public int show() {   // Ambiguity! Cannot satisfy both return types
        return 10;
    }
}

Result :
C is not abstract and does not override abstract method show() in B

____________________________________________________________________________________________________________________________________________
In Java, a non-static variable cannot be accessed directly inside a static method because static methods belong to the class itself, 
while non-static variables belong to an instance of the class.

class Example {
    int instanceVar = 10; // Non-static variable

    static void staticMethod() {
        System.out.println(instanceVar); // ❌ Error: Cannot access non-static variable from a static method
    }

    public static void main(String[] args) {
        staticMethod();
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------
 To access a non-static variable, create an instance of the class:

class Example {
    int instanceVar = 10;

    static void staticMethod() {
        Example obj = new Example();  // Create an instance
        System.out.println(obj.instanceVar);  // Access via instance
    }

    public static void main(String[] args) {
        staticMethod(); // This will work now
    }
}

____________________________________________________________________________________________________________________________________________
- Yes, we can make an inner class static, which is called a static nested class in Java.
- We can't make outer class static

class Outer {
    static int staticVar = 100;
    int instanceVar = 200;

    static class StaticInner { // ✅ Static nested class
        void display() {
            System.out.println("Static variable: " + staticVar); // ✅ Allowed
            // System.out.println("Instance variable: " + instanceVar); // ❌ Not allowed (Needs Outer class instance)
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // No need to create Outer class object
        Outer.StaticInner innerObj = new Outer.StaticInner();
        innerObj.display();
    }
}

____________________________________________________________________________________________________________________________________________
@FunctionalInterface annotation ensures that only one abstract method exists.
The lambda expression message -> System.out.println("Message: " + message) provides an implementation for showMessage.

@FunctionalInterface
interface MyFunctionalInterface {
    void showMessage(String message);
}

public class LambdaExample {
    public static void main(String[] args) {
        // Lambda expression implementing MyFunctionalInterface
        MyFunctionalInterface myFunc = message -> System.out.println("Message: " + message);
        
        // Calling the method
        myFunc.showMessage("Hello from Lambda!");
    }
}

____________________________________________________________________________________________________________________________________________
Java's Built-in Functional Interfaces (Consumer, Function, Predicate, Supplier)

import java.util.function.*;

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Consumer (T -> void)
        Consumer<String> consumer = message -> System.out.println("Consumed: " + message);
        consumer.accept("Hello Consumer");

        // Function (T -> R)
        Function<Integer, String> function = num -> "Number is " + num;
        System.out.println(function.apply(10));

        // Predicate (T -> boolean)
        Predicate<Integer> isEven = num -> num % 2 == 0;
        System.out.println("Is 4 even? " + isEven.test(4));

        // Supplier (() -> T)
        Supplier<Double> randomValue = () -> Math.random();
        System.out.println("Random Value: " + randomValue.get());
    }
}

____________________________________________________________________________________________________________________________________________
Rules for Exception Handling in Method Overriding:
** If a parent class method declares an exception using throws, the behavior of the child class method (overridden method) 
depends on the following rules:
- Same Exception: The child class method can declare the same exception as the parent class method.
- Subclass Exception: The child class method can declare a subclass of the exception declared in the parent class.
- No Exception: The child class method can choose not to declare any exception, even if the parent method declares one.
- Super Exception Not Allowed: The child class method cannot declare a broader (superclass) exception than the parent method.

class Parent {
    void show() throws Exception {
        System.out.println("Parent method");
    }
}

class Child extends Parent {
    @Override
    void show() throws Exception { // Same exception is allowed
        System.out.println("Child method");
    }

class Child extends Parent {
    @Override
    void show() throws ArithematicalException { // Child exception is allowed
        System.out.println("Child method");
    }
}

** If the parent class method does not declare any exception, the overridden method in the child class cannot
declare a checked exception. However, it can declare an unchecked (runtime) exception. Or no exception also allowed.

class Parent {
    void show() {  // No exception declared
        System.out.println("Parent method");
    }
}

class Child extends Parent {
    @Override
    void show() throws IOException { // ❌ Compilation Error: Cannot throw a checked exception
        System.out.println("Child method");
    }

 @Override
    void show() throws ArithmeticException { // ✅ Allowed (Unchecked Exception)
        System.out.println("Child method");
    }
}
____________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________




